import chisel3._
import chiseltest._
import org.scalatest.flatspec.AnyFlatSpec

// The test is generated by ChatGPT 5.2

class PredictorSpec extends AnyFlatSpec with ChiselScalatestTester {

  "Predictor" should "update PHT and allow immediate read after update" in {
    test(new Predictor) { dut =>
      val pc = 3.U(10.W)

      dut.io.update_info.valid.poke(false.B)
      dut.io.update_info.bits.hashed_pc.poke(0.U)
      dut.io.update_info.bits.actual_result.poke(false.B)

      dut.io.queried_pc.poke(pc)
      dut.clock.step(1)

      dut.io.predict_result.expect(false.B)

      def doTakenUpdateAndRead(): Boolean = {
        dut.io.update_info.valid.poke(true.B)
        dut.io.update_info.bits.hashed_pc.poke(pc)
        dut.io.update_info.bits.actual_result.poke(true.B)

        dut.clock.step(1)

        dut.io.update_info.valid.poke(false.B)
        dut.io.queried_pc.poke(pc)

        val pred = dut.io.predict_result.peekBoolean()
        pred
      }

      // 连续做 4 次 taken 更新
      val p1 = doTakenUpdateAndRead()
      // 第一次更新后：history=01，查询索引是 pc##01，对应计数器还在 0，预测应为 false
      assert(!p1, s"after 1st update, predict should still be false, got $p1")

      val p2 = doTakenUpdateAndRead()
      // 第二次：history=11，查询索引 pc##11，对应计数器还在 0，预测还是 false
      assert(!p2, s"after 2nd update, predict should still be false, got $p2")

      val p3 = doTakenUpdateAndRead()
      // 第三次：history=11，pc##11 的 counter 从 0->1（01），MSB 仍为 0，预测 false
      assert(!p3, s"after 3rd update, predict should still be false, got $p3")

      val p4 = doTakenUpdateAndRead()
      // 第四次：history=11，pc##11 的 counter 从 1->2（10），MSB=1，预测应变为 true
      assert(p4, s"after 4th update, predict should become true, got $p4")
    }
  }

  "Predictor" should "behave like a two-level predictor (history + PHT)" in {
    test(new Predictor) { dut =>
      val pcInt = 7
      val pc    = pcInt.U(10.W)

      // ===== 软件模型初始化（完全模拟 Predictor 行为） =====
      // 4096 个 2-bit counter
      val phtSim = Array.fill(4096)(0) // 0~3
      // 2-bit local history
      var histSim = 0                  // 0~3, 初始 00

      def msb2bit(x: Int): Int = (x >> 1) & 1

      def simIndex: Int = (pcInt << 2) | histSim

      def simPredict(): Boolean = msb2bit(phtSim(simIndex)) == 1

      def simUpdate(taken: Boolean): Unit = {
        val idx  = simIndex
        val oldC = phtSim(idx)
        val newC =
          if (taken) math.min(3, oldC + 1)
          else       math.max(0, oldC - 1)
        phtSim(idx) = newC

        // 更新 2-bit history: {oldLSB, newBit}
        val newBit = if (taken) 1 else 0
        histSim = ((histSim & 1) << 1) | newBit
      }

      // ===== 硬件初始化 =====
      dut.io.update_info.valid.poke(false.B)
      dut.io.update_info.bits.hashed_pc.poke(0.U)
      dut.io.update_info.bits.actual_result.poke(false.B)

      dut.io.queried_pc.poke(pc)
      dut.clock.step(1)

      // 初始：软件/硬件都应该预测 false
      val hwPred0 = dut.io.predict_result.peekBoolean()
      val swPred0 = simPredict()
      assert(!hwPred0, s"initial hw predict should be false, got $hwPred0")
      assert(!swPred0, s"initial sw predict should be false, got $swPred0")

      // ===== 定义一个工具：对这个 pc 做一次 update + 检查预测 =====
      def oneStep(taken: Boolean): Unit = {
        // 1) 软件模型先更新
        simUpdate(taken)

        // 2) 对硬件发起 update
        dut.io.update_info.valid.poke(true.B)
        dut.io.update_info.bits.hashed_pc.poke(pc)
        dut.io.update_info.bits.actual_result.poke(taken.B)

        dut.clock.step(1) // 在这个上升沿更新硬件的 PHT & history

        dut.io.update_info.valid.poke(false.B)
        dut.io.queried_pc.poke(pc)

        // 3) 比较软件预测和硬件预测
        val hwPred = dut.io.predict_result.peekBoolean()
        val swPred = simPredict()
        assert(
          hwPred == swPred,
          s"mismatch: taken=$taken, histSim=$histSim, phtSim(index=${simIndex})=${phtSim(simIndex)}, hw=$hwPred, sw=$swPred"
        )
      }

      // ===== 连续喂一串 taken / not-taken 模式，验证行为一致 =====
      // 比如先 3 次 taken，1 次 not taken，再 4 次 taken
      val pattern = Seq(true, true, true, false, true, true, true, true, false, false, true, false, false, true)

      pattern.foreach { t =>
        oneStep(t)
      }

      // 最终软件预测
      val finalSwPred = simPredict()
      val finalHwPred = dut.io.predict_result.peekBoolean()

      // 再 double-check 一下
      assert(finalHwPred == finalSwPred, s"final hw=$finalHwPred, sw=$finalSwPred")
      // 并且 final 预测应当不是初始的 false（说明训练起作用了）
      assert(finalHwPred, s"after training pattern, prediction should have become true, got $finalHwPred")
    }
  }
}
