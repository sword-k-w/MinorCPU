import chisel3._
import chiseltest._
import org.scalatest.flatspec.AnyFlatSpec

// The test is basically generated by ChatGPT 5.2

class PredictorSpec extends AnyFlatSpec with ChiselScalatestTester {

  // "Predictor" should "update PHT and allow immediate read after update" in {
  //   test(new Predictor) { dut =>
  //     val pc = 3.U(10.W)
  //
  //     dut.io.update_info.valid.poke(false.B)
  //     dut.io.update_info.bits.hashed_pc.poke(0.U)
  //     dut.io.update_info.bits.actual_result.poke(false.B)
  //
  //     dut.io.queried_pc.poke(pc)
  //     dut.clock.step(1)
  //
  //     dut.io.predict_result.expect(false.B)
  //
  //     def doTakenUpdateAndRead(): Boolean = {
  //       dut.io.update_info.valid.poke(true.B)
  //       dut.io.update_info.bits.hashed_pc.poke(pc)
  //       dut.io.update_info.bits.actual_result.poke(true.B)
  //
  //       dut.clock.step(1)
  //
  //       dut.io.update_info.valid.poke(false.B)
  //       dut.io.queried_pc.poke(pc)
  //
  //       val pred = dut.io.predict_result.peekBoolean()
  //       pred
  //     }
  //
  //     // 连续做 4 次 taken 更新
  //     val p1 = doTakenUpdateAndRead()
  //     // 第一次更新后：history=01，查询索引是 pc##01，对应计数器还在 0，预测应为 false
  //     assert(!p1, s"after 1st update, predict should still be false, got $p1")
  //
  //     val p2 = doTakenUpdateAndRead()
  //     // 第二次：history=11，查询索引 pc##11，对应计数器还在 0，预测还是 false
  //     assert(!p2, s"after 2nd update, predict should still be false, got $p2")
  //
  //     val p3 = doTakenUpdateAndRead()
  //     // 第三次：history=11，pc##11 的 counter 从 0->1（01），MSB 仍为 0，预测 false
  //     assert(!p3, s"after 3rd update, predict should still be false, got $p3")
  //
  //     val p4 = doTakenUpdateAndRead()
  //     // 第四次：history=11，pc##11 的 counter 从 1->2（10），MSB=1，预测应变为 true
  //     assert(p4, s"after 4th update, predict should become true, got $p4")
  //   }
  // }

  "Predictor" should "behave like a two-level predictor (history + PHT)" in {
    test(new Predictor) { dut =>
      val pcInt = 7
      val pc    = pcInt.U(10.W)

      val confidence = Array.fill(4096)(0) // 0~3
      val history = Array.fill(1024)(0) // 0~3

      def simIndex: Int = ((pcInt << 2) | (history(pcInt) & 3)) & 4095

      def simPredict(): Boolean = (confidence(simIndex) & 2) == 2

      def simUpdate(taken: Boolean): Unit = {
        val idx  = simIndex
        val oldC = confidence(idx) & 3
        val newC =
          if (taken) math.min(3, oldC + 1)
          else       math.max(0, oldC - 1)
        confidence(idx) = newC

        // update 2-bit history: {oldLSB, newBit}
        val newBit = if (taken) 1 else 0
        history(pcInt) = ((history(pcInt) & 1) << 1) | newBit
      }

      // ===== 硬件初始化 =====
      dut.io.update_info.valid.poke(false.B)
      dut.io.update_info.bits.hashed_pc.poke(0.U)
      dut.io.update_info.bits.actual_result.poke(false.B)

      dut.io.queried_pc.poke(pc)
      dut.clock.step(1)

      val hardPred = dut.io.predict_result.peekBoolean()
      val softPred = simPredict()
      assert(!hardPred, s"initial hw predict should be false, got $hardPred")
      assert(!softPred, s"initial sw predict should be false, got $softPred")

      def oneStep(taken: Boolean): Unit = {

        dut.io.update_info.valid.poke(false.B)
        dut.io.queried_pc.poke(pc)

        val hwPred = dut.io.predict_result.peekBoolean()
        val swPred = simPredict()
        assert(
          hwPred == swPred,
          s"mismatch: taken=$taken, history(index=$pcInt)=${history(pcInt)}, " +
              s"confidence(index=${simIndex})=${confidence(simIndex)}, hw=$hwPred, sw=$swPred"
        )
        println(s"Expect $swPred, matched!")

        simUpdate(taken)

        dut.io.update_info.valid.poke(true.B)
        dut.io.update_info.bits.hashed_pc.poke(pc)
        dut.io.update_info.bits.actual_result.poke(taken.B)

        dut.clock.step(1)
      }

      val pattern = Seq(true, true, true, false, true, true, true, true, false, false, true, false, false, true)

      pattern.foreach { t =>
        oneStep(t)
      }
    }
  }
}
